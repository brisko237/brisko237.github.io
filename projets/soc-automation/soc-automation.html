<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOC Automation Project</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #e0e0e0;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        main {
            flex: 1;
            padding: 20px;
            max-width: 1200px; /* Augmentation de la largeur max */
            margin: 0 auto;
        }

        header {
            background-color: #1E1E1E;
            color: white;
            text-align: center;
            padding: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .profile-pic {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .terminal {
            background-color: #2a2a2a;
            color: #dcdcdc;
            font-family: 'Courier New', Courier, monospace;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            display: inline-block;  /* Cette propriété permet de rendre le terminal "en ligne" */
            width: auto;  /* La largeur s'ajuste au contenu */
            max-width: 100%;  /* Empêche qu'il dépasse 100% de la largeur de son parent */
        }

        .breadcrumb {
            margin: 0 auto 30px;
            max-width: 1200px; /* Augmentation pour correspondre */
            color: #e0e0e0;
            font-size: 1em;
            text-align: center;
            padding: 10px 0;
            overflow-wrap: break-word;
            word-break: break-word;
        }

        .breadcrumb a {
            color: #CCCCCC;
            text-decoration: none;
            transition: color 0.01s ease;
        }

        .breadcrumb a:last-child {
            color: #0077b5;
            font-weight: bold;
        }

        .breadcrumb a:hover {
            color: red;
            text-decoration: underline;
        }

        .breadcrumb a:last-child:hover {
            color: red;
        }

        .article-content {
            background-color: #1E1E1E;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.2);
        }

        .article-content h2 {
            font-size: 1.8em;
            margin-bottom: 15px;
            color: #FFFFFF;
        }

        .article-content p {
            font-size: 1.1em;
            color: #CCCCCC;
            margin-bottom: 20px;
        }

        .article-content img {
            width: 100%; /* Images fluides */
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
            box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.2);
        }

        .quote-container {
            max-width: 1100px; /* Alignement avec l'élargissement */
            margin: 40px auto;
            padding: 20px;
            background-color: #333333;
            color: #dcdcdc;
            font-size: 1.2em;
            font-style: italic;
            border-left: 5px solid #0077b5;
            border-radius: 8px;
            position: relative;
        }

        .quote-container::before, .quote-container::after {
            content: "“";
            font-size: 2em;
            color: #0077b5;
            position: absolute;
            font-weight: bold;
        }

        .quote-container::before {
            top: -10px;
            left: 10px;
        }

        .quote-container::after {
            content: "”";
            bottom: -10px;
            right: 10px;
        }

        footer {
            text-align: center;
            padding: 10px 0;
            font-size: 0.9em;
        }

        footer a {
            color: #0077b5;
            text-decoration: none;
            font-size: 1.1em;
            font-weight: 600;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Media queries */
        @media (max-width: 1024px) {
            .article-content, .breadcrumb, main {
                max-width: 90%;
                padding: 15px;
            }

            .article-content h2 {
                font-size: 1.5em;
            }
        }

        @media (max-width: 768px) {
            header {
                padding: 15px;
            }

            .article-content {
                padding: 15px;
            }

            .breadcrumb {
                font-size: 0.9em;
                padding: 5px;
            }

            .article-content h2 {
                font-size: 1.3em;
            }

            img {
                width: 100%;
                height: auto;
            }
        }

        @media (max-width: 480px) {
            header {
                font-size: 1.5em;
                padding: 10px;
            }

            .breadcrumb {
                font-size: 0.8em;
                padding: 5px;
            }

            .profile-pic {
                width: 80px;
                height: 80px;
            }

            .article-content h2 {
                font-size: 1.2em;
            }

            .quote-container {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>

    <header>
        <a href="../../../brisko237.github.io/">
            <img src="../../images/photo.jpg" alt="Brice Temo" class="profile-pic">
        </a>
    </header>

    <nav class="breadcrumb">
        <a href="../../brisko237.github.io/">Accueil</a> > <a href="../../projets.html">Mes projets</a> > <a href="soc-automation.html">SOC Automation Project</a>
    </nav>       
    <h1 style="text-align: center;">SOC Automation Project</h1>
    <main>
        <section class="article-content">
            <p>L'idée de ce projet a été de découvrir comment l'automatisation du SOC améliore la réponse aux incidents et accélère la détection des menaces.
            <br>Les éléments de ce lab :
            <br><br><img src="../../images/cloud.png" style="width: 30px; height: 30px; vertical-align: middle; margin-right: 5px;"> Wazuh ? -> Plateforme open-source de cybersécurité intégrant les fonctionnalités d'un SIEM et d'un XDR dans une seule solution.
            <br><img src="../../images/cloud.png" style="width: 30px; height: 30px; vertical-align: middle; margin-right: 5px;"> TheHive -> Plateforme de gestion des incidents de sécurité
            <br><img src="../../images/cloud.png" style="width: 30px; height: 30px; vertical-align: middle; margin-right: 5px;"> Shuffle -> Plateforme open-source SOAR
            <br><img src="../../images/on-premise.png" style="width: 30px; height: 30px; vertical-align: middle; margin-right: 5px;"> Machine cliente Windows             
            <br><br>Afin d'avoir une idée plus claire de comment tout cela va fonctionner voici un schéma du projet :
            <br><br><img src="../../images/soc-automation/socautomationscheme.png" 
            style="width: 60%; height: auto; margin: 10px auto; display: block;">
            <br><br>La première étape a consisté à mettre en place une VM sous Windows 10 (qui dans notre cas représente le client windows au sein duquel va être installé l'agent Wazuh).
            <br>On va au sein de ce client installé Sysmon qui est un service et driver fournit dans le package Sysinternals de Microsoft permettant la journalisation des évènements Windows surtout sur les évènements de sécurité système (ex : Création de processus, modification de l'heure de création d'un fichier, connexion réseau, modification de l'état du service Sysmon, 
            fin d'un processus, chargement de pilote, etc...)
            <br>Il va agir comme un outil de détection.
            <br><br>Pour ce faire rien de plus, on se rend sur le site de Microsoft <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/sysmon" target="_blank">https://learn.microsoft.com/en-us/sysinternals/downloads/sysmon</a> et on télécharge tout simplement Sysmon.
            <br>Pour l'installer cependant, nous allons lui spécifier un fichier de configuration lors de l'installation pour nous éviter d'en créer une de zéro
            <a href="https://github.com/olafhartong/sysmon-modular" target="_blank">https://github.com/olafhartong/sysmon-modular</a>.
            <br>Nous pouvons vérifier l'installation de Sysmon directement en se rendant dans Services et vérifier que Sysmon y apparaît bien.
            <br><br>Maintenant que nous avons notre client windows 10 avec Sysmon, place à la deuxième étape qui consiste à mettre en place nos serveurs Wazuh Manager ainsi que TheHive.
            <br><br>Pour rappel, notre serveur Wazuh va recevoir les évènements provenant de l'agent (client Windows 10).
            <br><br>Ces deux serveurs sont crées sur le cloud car on doit pouvoir y accéder depuis Internet.
            <br><br>Voici leur spécifications :
            <br>RAM : 8 GB RAM
            <br>HDD : 50 GB HDD
            <br>OS : Ubuntu 24.04 LTS
            <img src="../../images/soc-automation/digitalocean-socautomation.png">
            <br>Pour information "TheHive utilizes Cassandra and Elasticsearch databases for data management and indexing purposes", raison pour laquelle il faut Cassandra et Elasticsearch d'installé avant de pouvoir utiliser TheHive.
            <br><br>Ceci étant fait passons dès maintenant aux configurations de TheHive et de Wazuh Server!
            <br>Commençons par la configuration de TheHive :
            <br>Dans un premier temps, on va configurer Cassandra qui agit en tant que base de données.
            <br><div class="terminal">nano /etc/cassandra/cassandra.yaml</div>
            <br><br>On modifiera alors le nom du cluster si on le souhaite mais surtout plusieurs adresses dont :
            <br><br>• Listen address : 
            <br>Qui correspond à l'adresse IP utilisée par le noeud Cassandra pour écouter les connexions provenant d'autres noeuds du cluster.
            <br><br>• RPC Address :
            <br>Cette adresse IP est utilisée pour les communications entre Cassandra et les clients (ex : TheHive), elle permettra aux autres applications de s'y connecter et d'envoyer des requêtes.
            <br><br>• Seed address :
            <br>Ce sont des adresses qui aident à intier la communication et l'organisation dans un cluster Cassandra en indiquant aux nouveaux noeuds où se trouvent les autres noeuds du cluster.
            <br><br><img src="../../images/soc-automation/thehive-configuration.png" style="width: 60%; height: auto; margin: 10px auto; display: block;">
            <br><br>Une fois cela fait on redémarre tout simplement le service.
            <br><br>Toujours dans la configuration de TheHive on va s'attaquer dès lors à celle d'Elastic Search.
            <br><br><div class="terminal">nano /etc/elasticsearch/elasticsearch.yml</div>
            <br><br>Il faudra dans un premier temps décommenté les lignes suivantes "cluster.name", "node.name" et "http.port", en revanche il faudra modifier la ligne network.host en y ajoutant notre IP publique.
            <br><br><img src="../../images/soc-automation/thehive-elk-configuration-.png" style="width: 60%; height: auto; margin: 10px auto; display: block;">
            <br><br>On redémarre le service et on vérifie son statut comme pour Cassandra.
            <br><br><img src="../../images/soc-automation/thehive-elk-configuration-status.png" style="width:50%; height: auto; margin: 10px auto; display: block;">
            <br><br>Une fois cela fait on peut dès à présent configurer à proprement parler TheHive, enfin pas tout à fait il faut juste avant donner la permission à l'utilisateur thehive et au groupe thehive au répertoire /opt/thp.
            <br><br>Ceci fait, on peut enfin se rendre dans 
            <br><br><div class="terminal">nano/etc/thehive/application.conf</div>
            <br><br>Où on va modifier notamment les valeurs hostname par notre IP publique pour nous donner l'accès.
            <br><br>On enregistre la configuration on démarre et vérifie le statut du service et hop !
            <br><br>Nous voilà sur TheHive ! 
            <br><br><img src="../../images/soc-automation/thehive-authentication-panel.png" style="width: 50%; height: auto; margin: 10px auto; display: block;">
            <br><br>Maintenant que TheHive est configuré, place à la configuration de Wazuh!
            <br><br>On va dans un premier temps se connecter au dashboard par le biais de nos identifiants donnés lors de l'installation.
            <br><br>Une fois connecté on remarque qu'aucun agent n'a été ajouté cela est normal, puisque nous n'avons effectué aucune action en ce sens.
            <br>De ce fait, on va alors ajouter un agent.
            <br><br><img src="../../images/soc-automation/wazuh-dashboard.png" style="width:50%; height: auto; margin: 10px auto; display: block;">
            <br><br>On se retrouve alors au sein de la page de déploiement où l'on va devoir renseigner le package que l'on souhaite télécharger et installer sur le système cible.
            <br>Dans notre cas, Windows ainsi que d'autres options comme le nom de l'agent etc...
            <br><br>Enfin, la commande d'installation nous est alors fournie accompagnée de celle pour démarrer le service sur la machine cliente.
            <br><br><img src="../../images/soc-automation/wazuh-deploy-agent.png" style="width: 50%; height: auto; margin: 10px auto; display: block;">
            <br><br>On se rend alors sur notre Windows 10 qui est une machine cliente je rappelle pour lancer les commandes d'installation
            <br><br><img src="../../images/soc-automation/wazuh-configuration-agent.png" style="width: 75%; height: auto; margin: 10px auto; display: block;">
            <br><br>On peut vérifier la bonne installation en revenant dans le dashboard et on devrait alors apercevoir un agent apparaître
            <br><br><br>Maintenant nos actifs en place la prochaine étape va consister à générer de la télémétrie via la machine windows 10 et s'assurer que c'est bien ingéré au sein de Wazuh Manager.
            <br><br>Plus précisément, l'idée va être d'envoyer de la télémétrie contenant mimikatz en ayant au préalable configuré Wazuh sur la machine cliente pour qu'il transfère bien les évènements de type "mimikatz" et enfin, l'idée finale est alors de déclencher une alerte qui aura également été crée au préalable (suite à la détection de mimikatz).
            <br><br>Dans Wazuh, sur la machine cliente, le fichier "ossec.conf" est celui qui détermine les logs à surveiller, les règles de détection et les actions de sécurité à appliquer pour l'analyse de logs
            <br><br>Celui-ci doit être modifié pour permettre à Wazuh de recevoir les activités liées à l'utilisation de mimikatz car les journaux Windows Standard ne le permettent pas.
            <br><br>On va donc dans la partie "Log analysis" de l'ossec.conf y ajouter Sysmon  :
            <br><br><img src="../../images/soc-automation/wazuh-ossec.conf-sysmon.png" style="width: 50%; height: auto; margin: 10px auto; display: block;">
            <br><br>On peut dès lors, redémarrer le service Wazuh au sein de la machine et se rendre sur notre dashboard Wazuh pour y vérifier la bonne apparition des évènements Sysmon.
            <br><br><img src="../../images/soc-automation/wazuh-validation-sysmon.png" style="width: 100%; height: auto; margin: 10px auto; display: block;">
            <br><br>Parfait ! 
            <br>On reçoit bien les évènements de notre machine cliente (win10-client) liés à Sysmon au sein du dashboard !
            <br><br>La prochaine étape va consister à télécharger mimikatz sur cette machine.
            <br>Bien évidemment pour faire cela nous allons devoir désactiver Windows Defender ou au moins ajouter le dossier téléchargements en exclusion au sein des paramètres de Windows Defender.
            <br><br>Ceci étant fait on télécharge et on démarre mimikatz au sein d'un terminal PowerShell puis on se rend sur notre dashboard Wazuh en espérant qu'il ait détecté quelque chose.
            <br><br><img src="../../images/soc-automation/mimikatz-running.png" style="width: 60%; height: auto; margin: 10px auto; display: block;">
            <br><br>Malheureusement, cela ne va pas être détecté instantanément par Wazuh car par défaut, pas tous les logs vont être affichés au sein du dashboard.
            <br>Seulement ceux qui déclenchent une règle vont être affichées c'est pour cela que l'on va configurer Wazuh de sorte a ce qu'il les affiche tous et ce, qu'ils répondent à une règle ou non.
            <br>L'idée est de faire en sorte que le Wazuh manager archive tous les logs et nous permet d'effectuer une recherche dans celle-ci.
            <br><br>Bien évidemment cela est pertinent uniquement pour des situations de test comme pour ce lab par exemple.
            <br><br>Affichons donc tous les logs !
            <br>Comme pour la machine cliente, le serveur Wazuh dispose également d'un fichier ossec.conf dans lequel on va passer les paramètres "logall" et "logall_json" à "yes"
            <br><br><img src="../../images/soc-automation/wazuh-manager-configuration.png" style="width: 60%; height: auto; margin: 10px auto; display: block;">
            <br><br>Maintenant ceci fait on va se rendre dans le fichier "filebeat.yml" qui est le fichier déterminant comment les logs seront collectés traités et envoyés à Elasticsearch dans notre cas pour passer la variable enabled à true car en effet, ayant activé tous les logs ceux-ci vont être contenus au sein du dossier archives et pour les voir s'afficher il faut autoriser les archives au sein du filebeat.
            <br><br>Après avoir redémarré respectivement le service wazuh-manager et le filebeat, de retour sur notre dashboard nous allons créer un "Index patterns" qui va nous permettre d'afficher tous les logs qu'ils répondent à une règle ou non.
            <br><br>Ce pattern index maintenant crée si depuis notre machine cliente on regénère de la donnée avec mimikatz (relançons par exemple) et que l'on tape mimikatz dans notre index préalable créée sur Wazuh on devrait cette fois bien avoir de la donnée!
            <br><br><img src="../../images/soc-automation/wazuh-detection-mimikatz.png" style="width: 100%; height: auto; margin: 10px auto; display: block;">
            <br><br>Bingo !
            <br>On reçoit bien les évènements liés à mimikatz, on en voit 2 précisément mais celui qui nous intéresse est celui content l'event ID 1 car si l'on se réfère à la documentation de sysmon l'event ID 1 fournit des informations sur la création de processus et est donc plus fiable que l'event ID 7 juste au dessus.
            <br><br>C'est une bonne chose de voir que l'on peut détecter du mimikatz mais le but est plutôt que d'aller faire toute cette recherche d'être directement alerté !
            <br>C'est pour cela que l'on va créer une règle de détection de cet event ID 1 de Sysmon avec le nom de fichier mimikatz.
            <br><br>À savoir qu'au sein de Wazuh, une règle existe pour les évènements Sysmon liés à l'Event ID1 dont on va se servir pour custom notre propre règle en y ajoutant notamment le fait qu'en plus d'avoir cet Event ID  de 1, il faut que le nom ORIGINAL du fichier soit mimikatz, donc même si le nom du fichier a été changé en cours de route puisqu'on se base sur le nom ORIGINAL cela déclenchera tout de même l'alerte.
            <br><br><img src="../../images/soc-automation/custom-rule-wazuh.png" style="width: 60%; height: auto; margin: 10px auto; display: block;">
            <br><br>Je vais volontairement changer le nom de mimikatz par autre chose pour prouver que même si on modifie le nom de l'application, l'alerte va tout de même se déclencher.
            <br><br><img src="../../images/soc-automation/wazuh-mimikatz-detected.png" style="width: 100%; height: auto; margin: 10px auto; display: block;">
            <br><br>Nous avons bien des alertes qui se déclenchent dûes au lancement de mimikatz et si l'on regarde en détails, on s'aperçoit que dans le champ "data.win.eventdata.image" on y trouve un nom différent de mimikatz.exe tandis que dans le data.win.eventdata.originalFileName on le trouve bien.
            <br><br><img src="../../images/soc-automation/wazuh-details-alert.png" style="width: 80%; height: auto; margin: 10px auto; display: block;">
            <br><br>Parfait, arrivé à cette étape nous avons notre SIEM/XDR (Wazuh) ainsi que notre plateforme de réponse à incident (TheHive) qui sont configurés, cependant ces deux plateformes ne communiquent pas ensemble.
            <br><br>C'est là que le SOAR (Shuffle) entre en jeu même si l'intermédiation n'est pas son but premier.
            <br>Pour faire simple, Shuffle est une plateforme SOAR opensource qui permet aux équipes de sécurité d’orchestrer et d’automatiser le traitement d’incident sécurité de bout en bout.
            <br><br>Dans cette quatrième étape, le but va être via Shuffle de créer un workflow qui va : 
            <br>Recevoir une alerte mimikatz de Wazuh Manager -> Extraire le hash SHA256 du fichier -> Vérifier le score de réputation sur VirusTotal -> Créer une alerte sur TheHive -> Envoyer un mail à l'analyste SOC (moi) afin qu'il puisse commencer l'investigation.
            <br><br>Pour recevoir une alerte mimikatz de Wazuh il faut impérativement connecter Shuffle à Wazuh, pour cela, on va utiliser une fonctionnalité présente au sein du workflow sur Shuffle qui est le webhook.
            <br><br><img src="../../images/soc-automation/shuffle-wazuh-webhook.png" style="width: 50%; height: auto; margin: 10px auto; display: block;">
            <br><br>Une fois ce webhook ajouté on va y copier le webhook URL que l'on va devoir ajouté au sein d'un "integration tag" que l'on va lui même ajouté au fichier de configuration de Wazuh, je ne rentrerai pas plus dans le détail de l'intégration de Wazuh avec Shuffle pour plus d'informations la documentation de Wazuh est disponible ici : <a href="https://wazuh.com/blog/integrating-wazuh-with-shuffle"> https://wazuh.com/blog/integrating-wazuh-with-shuffle</a>
            <br><br><img src="../../images/soc-automation/wazuh-shuffle-integration.png" style="width: 60%; height: auto; margin: 10px auto; display: block;">
            <br><br>Parfait, pour tester la bonne intégration on retourne sur Shuffle et on démarre tout simplement le webhook, celui-ci nous affiche alors les détails de l'alerte générés sur Wazuh.
            <br><br><img src="../../images/soc-automation/shuffle-wazuh-webhook-validation.png" style="width: 85%; height: auto; margin: 10px auto; display: block;">
            <br><br>Le premier objectif de notre workflow (Recevoir les alertes mimikatz) est atteint. 
            <br>Dès à présent, nous souhaitons extraire le hash SHA256 du fichier et pour ce on va devoir ajouter un nouvel élément ("Shuffle Tool") au sein du workflow qui va extraire le SHA256 du fichier contenu dans l'alerte à l'aide d'une regex que voici : SHA256=([A-Fa-f0-9]{64})
            <br><br>Cette expression régulière va au sein des détails de l'alerte wazuh récupérer la valeur SHA256 uniquement qui va être affichée par le Shuffle Tool
            <br><br><img src="../../images/soc-automation/shuffle-sha256-extraction.png" style="width: 60%; height: auto; margin: 10px auto; display: block;">
            <br><br>C'est magnifique !
            <br>On a maintenant le SHA256 extrait on peut alors automatiser l'envoi de ce hash à Virus Total qui va vérifier sa réputation.
            <br>Pour faire ceci il va falloir dans un premier temps créer un compte sur Virus Total (que je possède déjà donc pas de création) et bien copier l'API key qui va être utilisée sur Shuffle car oui, on utilise l'API de Virus Total pour cela.
            <br><br>De retour sur Shuffle, on va ajouter un nouvel élément de type "Virustotal" au workflow dans lequel on va devoir notamment renseigner l'API key et l'action que l'on souhaite effectuer ("Get a hash report" dans notre cas) et bingo, on reçoit bien un retour de notre requête sur Virustotal avec le sha256, on obtient alors des infos sur le fichier en question.
            <br><br><img src="../../images/soc-automation/shuffle-sha256-virustotal-results.png" style="width: 70%; height: auto; margin: 10px auto; display: block;">
            <br><br>Place maintenant à l'intégration de Shuffle avec TheHive.
            <br><br>Après avoir ouvert le flux réseau en 0.0.0.0:9000 vers TheHive notre plateforme on va alors pouvoir se rendre sur notre dashboard et créer 2 nouveaux utilisateurs l'un que je vais appeler "iambrice" (Analyste SOC) et un second du nom de "shuffle" avec lequel on va cette fois-ci lui attribuer une clé API qui sera utilisé pour l'authentification de notre SOAR à la plateforme TheHive.
            <br>Comme pour l'intégration précédente, on va ajouter l'élement TheHive au workflow qui nous permettra d'effectuer une requête API pour créer une alerte sur TheHive et ce, depuis Shuffle.
            <br><br>Voici le body de la requête JSON
            <br><br><div class="terminal">{
                <br>"type": "Internal",
                <br>"description": "Mimikatz detected on host: $exec.text.win.system.computer from user: $exec.text.win.eventdata.user",
                <br>"source": "Wazuh",
                <br>"sourceRef": "Rule 100002",
                <br>"title": "Mimikatz Detection",
                <br>"summary": "Mimikatz activity detection on host: and the process ID is: $exec.text.win.eventdata.processId and the Command line is: $exec.text.win.eventdata.commandLine"
              <br>}</div>
              <br><br><img src="../../images/soc-automation/shuffle-thehive-authentication.png" style="width: 75%; height: auto; margin: 10px auto; display: block;">
            <br>Ceci étant fait on peut alors rerun le workflow et si tout a bien été effectué, en se rendant sur TheHive on devrait alors voir une nouvelle alerte apparaître, ce qui est bien le cas !
            <br><br><img src="../../images/soc-automation/alerte-shuffle-thehive.png" style="width: 90%; height: auto; margin: 10px auto; display: block;">
            <br><br>Notre alerte a bien été crée avec les arguments renseignés au sein du body JSON précédemment!
            <br><br>Ok parfait c'est bien beau d'avoir toutes ces créations d'alertes d'intégration sur différentes plateforme mais si l'information que tout cela a été crée n'est pas donnée à l'analyste SOC cela en devient inefficient, c'est pour cela que l'on va simultanément alerter par mail l'analyste.
            <br><br>De retour sur notre SOAR, Shuffle on va encore ajouter un élément qui cette fois-ci est Email.
            <br>Au sein de celui-ci on y renseigne l'adresse mail à laquelle on souhaite envoyer le mail, le titre et le corps du mail.
            <br><br><img src="../../images/soc-automation/alerte-sendmail-socanalyst.png" style="width: 25%; height: auto; margin: 10px auto; display: block;">
            <br><br>On sauvegarde le tout et on run le workflow.
            <br><br>Bingo!
            <br><br>On reçoit bien un mail sur notre boîte nous informant de l'utilisation de mimikatz sur un hôte !
            <br><br><img src="../../images/soc-automation/mail-received-socanalyst.png" style="width: 70%; height: auto; margin: 10px auto; display: block;">
            <br><br>Ce projet inspiré de la chaîne de YouTube de MyDFIR (<a href="https://www.youtube.com/@MyDFIR"> https://www.youtube.com/@MyDFIR</a>) touche à sa fin et m'aura permis de mettre en exergue l'automatisation au sein d'un environnement SOC par le biais notamment du SOAR.
            <br><br>Cela permet de gagner, ce qu'il y a bien souvent de plus précieux : du temps.
            <br>Je vous remercie pour la lecture entière de ce projet que j'ai trouvé fort intéressant et passionnant à effectuer.
            <br><br>(Une version "pour aller plus loin" de ce projet consisterait à créer un workflow de "réponse" à l'alerte qui par exemple isolerait la machine hôte du réseau).
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        </p>
        
        </section>
    </main>

    <footer>
        <a href="https://linkedin.com/in/iamskyze" target="_blank">LinkedIn</a>
    </footer>
</body>
</html>
